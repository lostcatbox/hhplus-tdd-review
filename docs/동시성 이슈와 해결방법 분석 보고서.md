# λ™μ‹μ„± μ΄μ ν•΄κ²°λ°©λ²• λΉ„κµ λ³΄κ³ μ„

## π“‹ κ°μ”

- ν„μ¬ ν”„λ΅μ νΈμ—μ„λ” `@Synchronized` μ–΄λ…Έν…μ΄μ…μ„ μ‚¬μ©ν•μ—¬ ν¬μΈνΈ μ¶©μ „/μ‚¬μ© μ‹ λ°μƒν•  μ μλ” λ™μ‹μ„± μ΄μλ¥Ό ν•΄κ²°ν•κ³  μμµλ‹λ‹¤.
- λ³΄κ³ μ„ μ‘μ„± ν›„ `@Synchronized` λ‹¨μΌ μ„λ²„μ—μ„ λ³΄λ‹¤ μ ν•©ν• μ‚¬μ©μλ³„ μ„Έλ°€ν• λ½ μ μ–΄λ΅ λ³€κ²½ν•μ—¬, μ„±λ¥ κ°μ„ μ„ μ΄λ¤„λƒμµλ‹λ‹¤.(`ConcurrentHashMap<Long, ReentrantLock>()` ν™μ©)
- λ³Έ λ³΄κ³ μ„μ—μ„λ” `@Synchronized` μ™Έμ λ‹¤μ–‘ν• λ™μ‹μ„± μ μ–΄ λ°©λ²•λ“¤μ„ μ΅°μ‚¬ν•κ³ , κ°κ°μ μ¥λ‹¨μ μ„ λΉ„κµ λ¶„μ„ν•©λ‹λ‹¤.

## π― λ™μ‹μ„± ν…μ¤νΈ μ”κµ¬μ‚¬ν•­ λ¶„μ„

### PointServiceIntegrationTest.kt ν•µμ‹¬ μ”κµ¬μ‚¬ν•­
- **100κ° λ™μ‹ μ¶©μ „ μ”μ²­**: λ¨λ“  μ”μ²­μ΄ μ„±κ³µν•κ³  μµμΆ… ν¬μΈνΈκ°€ μ •ν™•ν•΄μ•Ό ν•¨
- **100κ° λ™μ‹ μ‚¬μ© μ”μ²­**: μ”μ•΅ λ²”μ„ λ‚΄μ—μ„ λ¨λ“  μ”μ²­μ΄ μ„±κ³µν•΄μ•Ό ν•¨
- **λ³µν•© λ™μ‹μ„± ν…μ¤νΈ**: μ¶©μ „κ³Ό μ‚¬μ©μ΄ λ™μ‹μ— λ°μƒν•΄λ„ λ°μ΄ν„° μΌκ΄€μ„± μ μ§€
- **λ€λ‰ μ”μ²­ μ²λ¦¬**: 200κ°μ κµλ€ μ”μ²­μ—μ„λ„ μ •ν™•ν• ν¬μΈνΈ κ³„μ‚°

### ν•µμ‹¬ κ²€μ¦ μ΅°κ±΄
```kotlin
// λ¨λ“  μ”μ²­ μ„±κ³µ
assertThat(successCount.get()).isEqualTo(threadCount)
// μµμΆ… ν¬μΈνΈ μ •ν™•μ„±
assertThat(finalUserPoint.point).isEqualTo(expectedTotalAmount)
```

## π”§ λ™μ‹μ„± ν•΄κ²° λ°©λ²• λΉ„κµ

### 1. @Synchronized

#### κµ¬ν„ λ°©μ‹
```kotlin
@Service
class PointService {
    @Synchronized
    override fun charge(userId: Long, amount: Long): UserPoint {
        // λΉ„μ¦λ‹μ¤ λ΅μ§
    }

    @Synchronized
    override fun use(userId: Long, amount: Long): UserPoint {
        // λΉ„μ¦λ‹μ¤ λ΅μ§
    }
}
```

#### μ¥μ 
- β… κµ¬ν„μ΄ κ°„λ‹¨ν•κ³  μ§κ΄€μ 
- β… JVM λ λ²¨μ—μ„ μ¤λ λ“ μ•μ „μ„± λ³΄μ¥
- β… λ°λ“λ½ μ„ν—μ΄ μ μ
- β… κΈ°μ΅΄ ν…μ¤νΈ λ¨λ‘ ν†µκ³Ό

#### λ‹¨μ 
- β μ „μ²΄ λ©”μ„λ“ λ‹¨μ„ λ½μΌλ΅ μ„±λ¥ μ €ν•
- β λ‹¨μΌ JVM λ‚΄μ—μ„λ§ λ™μ‘
- β μ„Έλ°€ν• λ½ μ μ–΄ λ¶κ°€λ¥
- β ν™•μ¥μ„± μ ν•

---

### 2. ReentrantLock

#### κµ¬ν„ λ°©μ‹
```kotlin
@Service
class PointService {
    private val lock = ReentrantLock()

    override fun charge(userId: Long, amount: Long): UserPoint {
        lock.lock()
        try {
            // λΉ„μ¦λ‹μ¤ λ΅μ§
        } finally {
            lock.unlock()
        }
    }
}
```

#### μ¥μ 
- β… μ„Έλ°€ν• λ½ μ μ–΄ κ°€λ¥
- β… tryLock()μΌλ΅ νƒ€μ„μ•„μ›ƒ μ„¤μ • κ°€λ¥
  - νƒ€μ„μ•„μ›ƒ μ„¤μ • μ‹ λ½ νλ“ μ‹λ„ μ‹κ°„ μ ν• κ°€λ¥
  - μμ‹ : `reentrantLock.tryLock(5, TimeUnit.SECONDS)`
- β… κ³µμ •μ„±(fairness) μ„¤μ • κ°€λ¥
  - κ³µμ •μ„± μλ―Έ : λ½ νλ“μ„ λ€κΈ° μ¤‘μΈ μ¤λ λ“λ“¤μ— λ€ν•μ—¬ κ°€μ¥ μ¤λ λ€κΈ°ν• μ¤λ λ“μ—κ² λ¨Όμ € λ½μ„ μ μ ν•  μ μλ„λ΅ μ°μ„ κ¶μ„ μ¤€λ‹¤
- β… μΈν„°λ½νΈ μ§€μ›

#### λ‹¨μ 
- β λ…μ‹μ  λ½ ν•΄μ  ν•„μ” (ν΄λ¨Ό μ—λ¬ κ°€λ¥μ„±)
- β `@Synchronized` λ°©μ‹λ³΄λ‹¤ λ³µμ΅ν•¨
- β λ‹¨μΌ JVM ν•μ •

---

### 3. μ‚¬μ©μλ³„ μ„Έλ°€ν• λ½ μ μ–΄(ν„μ¬ κµ¬ν„ λ°©μ‹)

#### κµ¬ν„ λ°©μ‹
```kotlin
@Service
class PointService {
    private val userLocks = ConcurrentHashMap<Long, ReentrantLock>()

    override fun charge(userId: Long, amount: Long): UserPoint {
        val lock = userLocks.computeIfAbsent(userId) { ReentrantLock() }
        lock.lock()
        try {
            // λΉ„μ¦λ‹μ¤ λ΅μ§
        } finally {
            lock.unlock()
        }
    }
}
```

#### μ¥μ 
- β… μ‚¬μ©μλ³„ λ…λ¦½μ μΈ λ½μΌλ΅ μ„±λ¥ μµμ ν™”
- β… μ„λ΅ λ‹¤λ¥Έ μ‚¬μ©μ μ”μ²­μ€ λ³‘λ ¬ μ²λ¦¬ κ°€λ¥
- β… λ™μΌ μ‚¬μ©μ μ”μ²­λ§ μ§λ ¬ν™”

#### λ‹¨μ 
- β λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μ¦κ°€ (μ‚¬μ©μλ³„ λ½ κ°μ²΄)
- β λ½ κ°μ²΄ μ •λ¦¬ λ΅μ§ ν•„μ”
- β κµ¬ν„ λ³µμ΅λ„
- β λ‹¨μΌ JVM ν•μ •

---

### 4. λ‚™κ΄€μ  λ½ (Optimistic Lock)

#### κµ¬ν„ λ°©μ‹
```kotlin
@Entity
data class UserPoint(
    @Id val id: Long,
    val point: Long,
    @Version val version: Long,
    val updateMillis: Long
)

@Service
@Transactional
class PointService {
    @Retryable(value = [OptimisticLockingFailureException::class])
    override fun charge(userId: Long, amount: Long): UserPoint {
        // λΉ„μ¦λ‹μ¤ λ΅μ§ - λ²„μ „ μ¶©λ μ‹ μλ™ μ¬μ‹λ„
    }
}
```

#### μ¥μ 
- β… λ½ μ—†μ΄ λ™μ‹μ„± μ μ–΄
- β… μ„±λ¥ μ°μ (μ¶©λμ΄ μ μ€ κ²½μ°)
- β… λ°λ“λ½ μ—†μ
- β… λ¶„μ‚° ν™κ²½ μ§€μ›

#### λ‹¨μ 
- β μ¶©λ μ‹ μ¬μ‹λ„ λ΅μ§ ν•„μ”
- β μ¶©λμ΄ λΉλ²ν•λ©΄ μ„±λ¥ μ €ν•
- β λ°μ΄ν„°λ² μ΄μ¤ μμ΅΄μ 
- β λ³µμ΅ν• μ¬μ‹λ„ λ΅μ§
- β Version ν•„λ“ κ΄€λ¦¬ ν•„μ”

---

### 5. λΉ„κ΄€μ  λ½ (Pessimistic Lock)

#### κµ¬ν„ λ°©μ‹
```kotlin
@Repository
interface UserPointRepository {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM UserPoint u WHERE u.id = :id")
    fun findByIdWithLock(id: Long): UserPoint?
}

@Service
@Transactional
class PointService {
    override fun charge(userId: Long, amount: Long): UserPoint {
        val userPoint = userPointRepository.findByIdWithLock(userId)
        // λΉ„μ¦λ‹μ¤ λ΅μ§
    }
}
```

#### μ¥μ 
- β… λ°μ΄ν„°λ² μ΄μ¤ λ λ²¨μ—μ„ λ½ λ³΄μ¥
- β… ν™•μ‹¤ν• λ™μ‹μ„± μ μ–΄
- β… λ³µμ΅ν• λΉ„μ¦λ‹μ¤ λ΅μ§μ— μ ν•©
- β… λ¶„μ‚° ν™κ²½ μ§€μ›

#### λ‹¨μ 
- β μ„±λ¥ μ €ν• (λ€κΈ° μ‹κ°„ μ¦κ°€)
- β λ°λ“λ½ κ°€λ¥μ„±
- β λ°μ΄ν„°λ² μ΄μ¤ μμ΅΄μ 
- β ν™•μ¥μ„± μ ν•
  - Application λ‹¨μ λ½ μ μ–΄ λ°©λ²•μ΄ μ•„λ‹ λ°μ΄ν„°λ² μ΄μ¤ λ λ²¨μ—μ„ λ½μ„ μ μ–΄ν•κΈ° λ•λ¬Έμ— ν™•μ¥μ„±μ΄ μ ν•λ¨

---

### 6. Redis λ¶„μ‚° λ½

#### κµ¬ν„ λ°©μ‹
```kotlin
@Service
class PointService {
    @Autowired
    private lateinit var redissonClient: RedissonClient

    override fun charge(userId: Long, amount: Long): UserPoint {
        val lock = redissonClient.getLock("point_lock:$userId")
        lock.lock(10, TimeUnit.SECONDS)
        try {
            // λΉ„μ¦λ‹μ¤ λ΅μ§
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock()
            }
        }
    }
}
```

#### μ¥μ 
- β… λ¶„μ‚° ν™κ²½ μ§€μ›
- β… μ μ—°ν• λ½ μ μ–΄
- β… μλ™ λ½ ν•΄μ  (TTL)

#### λ‹¨μ 
- β μ™Έλ¶€ μμ΅΄μ„± (Redis) ν•„μ”
- β λ„¤νΈμ›ν¬ μ¤λ²„ν—¤λ“
- β λ³µμ΅μ„± μ¦κ°€
- β Redis μ¥μ•  μ‹ μν–¥
  - λ λ””μ¤ ν΄λ¬μ¤ν„° λ“±μΌλ΅ λ³΄μ• κµ¬μ„± ν•„μ”
  - λ°±μ—… λ° μ¥μ•  μ΅°μΉ μ „λµ ν•„μ”

---
## π“ μ„±λ¥ λ° νΉμ„± λΉ„κµ


### μƒμ„Έ λΉ„κµν‘

| λ°©λ²• | μ„±λ¥ | κµ¬ν„λ³µμ΅λ„ | ν™•μ¥μ„± | λ¶„μ‚° ν™κ²½ μ§€μ› |
|------|------|-----------|--------|----|
| @Synchronized | β­β­ | β­β­β­β­β­ | β­β­ | β |
| ReentrantLock | β­β­β­ | β­β­β­ | β­β­ | β |
| μ‚¬μ©μλ³„ λ½ | β­β­β­β­ | β­β­ | β­β­ | β |
| λ‚™κ΄€μ  λ½ | β­β­β­β­ | β­β­ | β­β­β­β­ | β… |
| λΉ„κ΄€μ  λ½ | β­β­ | β­β­β­ | β­β­β­ | β… |
| Redis λ¶„μ‚° λ½ | β­ | β­ | β­β­β­β­β­ | β… |


### μ”κµ¬μ‚¬ν•­λ³„ μ „λµ

#### λ‹¨μΌ μ„λ²„μ—μ„ μ„±λ¥ μµμ ν™”
```kotlin
// μ‚¬μ©μλ³„ λ½μΌλ΅ κ°μ„ 
@Service
class PointService {
    private val userLocks = ConcurrentHashMap<Long, ReentrantLock>()

    private fun executeWithUserLock(userId: Long, action: () -> UserPoint): UserPoint {
        val lock = userLocks.computeIfAbsent(userId) { ReentrantLock() }
        lock.lock()
        try {
            return action()
        } finally {
            lock.unlock()
        }
    }

    override fun charge(userId: Long, amount: Long): UserPoint {
        return executeWithUserLock(userId) {
            // κΈ°μ΅΄ λΉ„μ¦λ‹μ¤ λ΅μ§
        }
    }
}
```

#### λ¶„μ‚° ν™κ²½μ—μ„ λ¶„μ‚° λ½ν‚Ή
```kotlin
// Redis λ¶„μ‚° λ½ λ„μ…
@Service
class PointService {
    @Autowired
    private lateinit var redissonClient: RedissonClient

    private fun executeWithDistributedLock(userId: Long, action: () -> UserPoint): UserPoint {
        val lockKey = "point_lock:$userId"
        val lock = redissonClient.getLock(lockKey)

        return try {
            if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                action()
            } else {
                throw IllegalStateException("λ½ νλ“ μ‹¤ν¨: $userId")
            }
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock()
            }
        }
    }
}
```


## π― κ²°λ΅ 

### ν„μ¬ λ‹¨μΌ μ„λ²„ ν™κ²½μ—μ„ μ„λΉ„μ¤ μ‹ κ³ λ ¤μ‚¬ν•­
1. **μ‚¬μ©μλ³„ μ„Έλ°€ν• λ½**: μ„±λ¥ μµμ ν™” (ν„μ¬ ν”„λ΅μ νΈ μ μ©)
2. **λ‚™κ΄€μ  λ½ λ„μ…**: λ°μ΄ν„°λ² μ΄μ¤ κΈ°λ° λ™μ‹μ„± μ μ–΄
3. **λ¶„μ‚° ν™κ²½ μ¤€λΉ„**: Redis λ¶„μ‚° λ½ μ•„ν‚¤ν…μ² μ„¤κ³„

### μ¶”ν›„ λ¶„μ‚° μ‹μ¤ν… λ„μ… μ‹ κ³ λ ¤μ‚¬ν•­ (λ¶„μ‚° μ‹μ¤ν…)
1. **Redis λ¶„μ‚° λ½**: λ§μ΄ν¬λ΅μ„λΉ„μ¤ μ•„ν‚¤ν…μ² μ§€μ›

---
