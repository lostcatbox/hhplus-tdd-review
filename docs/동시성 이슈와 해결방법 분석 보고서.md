# 동시성 이슈 해결방법 비교 보고서

## 📋 개요

- 현재 프로젝트에서는 `@Synchronized` 어노테이션을 사용하여 포인트 충전/사용 시 발생할 수 있는 동시성 이슈를 해결하고 있습니다.
- 보고서 작성 후 `@Synchronized` 단일 서버에서 보다 적합한 사용자별 세밀한 락 제어로 변경하여, 성능 개선을 이뤄냈습니다.(`ConcurrentHashMap<Long, ReentrantLock>()` 활용)
- 본 보고서에서는 `@Synchronized` 외의 다양한 동시성 제어 방법들을 조사하고, 각각의 장단점을 비교 분석합니다.

## 🎯 동시성 테스트 요구사항 분석

### PointServiceIntegrationTest.kt 핵심 요구사항
- **100개 동시 충전 요청**: 모든 요청이 성공하고 최종 포인트가 정확해야 함
- **100개 동시 사용 요청**: 잔액 범위 내에서 모든 요청이 성공해야 함
- **복합 동시성 테스트**: 충전과 사용이 동시에 발생해도 데이터 일관성 유지
- **대량 요청 처리**: 200개의 교대 요청에서도 정확한 포인트 계산

### 핵심 검증 조건
```kotlin
// 모든 요청 성공
assertThat(successCount.get()).isEqualTo(threadCount)
// 최종 포인트 정확성
assertThat(finalUserPoint.point).isEqualTo(expectedTotalAmount)
```

## 🔧 동시성 해결 방법 비교

### 1. @Synchronized

#### 구현 방식
```kotlin
@Service
class PointService {
    @Synchronized
    override fun charge(userId: Long, amount: Long): UserPoint {
        // 비즈니스 로직
    }

    @Synchronized
    override fun use(userId: Long, amount: Long): UserPoint {
        // 비즈니스 로직
    }
}
```

#### 장점
- ✅ 구현이 간단하고 직관적
- ✅ JVM 레벨에서 스레드 안전성 보장
- ✅ 데드락 위험이 적음
- ✅ 기존 테스트 모두 통과

#### 단점
- ❌ 전체 메서드 단위 락으로 성능 저하
- ❌ 단일 JVM 내에서만 동작
- ❌ 세밀한 락 제어 불가능
- ❌ 확장성 제한

---

### 2. ReentrantLock

#### 구현 방식
```kotlin
@Service
class PointService {
    private val lock = ReentrantLock()

    override fun charge(userId: Long, amount: Long): UserPoint {
        lock.lock()
        try {
            // 비즈니스 로직
        } finally {
            lock.unlock()
        }
    }
}
```

#### 장점
- ✅ 세밀한 락 제어 가능
- ✅ tryLock()으로 타임아웃 설정 가능
  - 타임아웃 설정 시 락 획득 시도 시간 제한 가능
  - 예시 : `reentrantLock.tryLock(5, TimeUnit.SECONDS)`
- ✅ 공정성(fairness) 설정 가능
  - 공정성 의미 : 락 획득을 대기 중인 스레드들에 대하여 가장 오래 대기한 스레드에게 먼저 락을 점유할 수 있도록 우선권을 준다
- ✅ 인터럽트 지원

#### 단점
- ❌ 명시적 락 해제 필요 (휴먼 에러 가능성)
- ❌ `@Synchronized` 방식보다 복잡함
- ❌ 단일 JVM 한정

---

### 3. 사용자별 세밀한 락 제어(현재 구현 방식)

#### 구현 방식
```kotlin
@Service
class PointService {
    private val userLocks = ConcurrentHashMap<Long, ReentrantLock>()

    override fun charge(userId: Long, amount: Long): UserPoint {
        val lock = userLocks.computeIfAbsent(userId) { ReentrantLock() }
        lock.lock()
        try {
            // 비즈니스 로직
        } finally {
            lock.unlock()
        }
    }
}
```

#### 장점
- ✅ 사용자별 독립적인 락으로 성능 최적화
- ✅ 서로 다른 사용자 요청은 병렬 처리 가능
- ✅ 동일 사용자 요청만 직렬화

#### 단점
- ❌ 메모리 사용량 증가 (사용자별 락 객체)
- ❌ 락 객체 정리 로직 필요
- ❌ 구현 복잡도
- ❌ 단일 JVM 한정

---

### 4. 낙관적 락 (Optimistic Lock)

#### 구현 방식
```kotlin
@Entity
data class UserPoint(
    @Id val id: Long,
    val point: Long,
    @Version val version: Long,
    val updateMillis: Long
)

@Service
@Transactional
class PointService {
    @Retryable(value = [OptimisticLockingFailureException::class])
    override fun charge(userId: Long, amount: Long): UserPoint {
        // 비즈니스 로직 - 버전 충돌 시 자동 재시도
    }
}
```

#### 장점
- ✅ 락 없이 동시성 제어
- ✅ 성능 우수 (충돌이 적은 경우)
- ✅ 데드락 없음
- ✅ 분산 환경 지원

#### 단점
- ❌ 충돌 시 재시도 로직 필요
- ❌ 충돌이 빈번하면 성능 저하
- ❌ 데이터베이스 의존적
- ❌ 복잡한 재시도 로직
- ❌ Version 필드 관리 필요

---

### 5. 비관적 락 (Pessimistic Lock)

#### 구현 방식
```kotlin
@Repository
interface UserPointRepository {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM UserPoint u WHERE u.id = :id")
    fun findByIdWithLock(id: Long): UserPoint?
}

@Service
@Transactional
class PointService {
    override fun charge(userId: Long, amount: Long): UserPoint {
        val userPoint = userPointRepository.findByIdWithLock(userId)
        // 비즈니스 로직
    }
}
```

#### 장점
- ✅ 데이터베이스 레벨에서 락 보장
- ✅ 확실한 동시성 제어
- ✅ 복잡한 비즈니스 로직에 적합
- ✅ 분산 환경 지원

#### 단점
- ❌ 성능 저하 (대기 시간 증가)
- ❌ 데드락 가능성
- ❌ 데이터베이스 의존적
- ❌ 확장성 제한
  - Application 단의 락 제어 방법이 아닌 데이터베이스 레벨에서 락을 제어하기 때문에 확장성이 제한됨

---

### 6. Redis 분산 락

#### 구현 방식
```kotlin
@Service
class PointService {
    @Autowired
    private lateinit var redissonClient: RedissonClient

    override fun charge(userId: Long, amount: Long): UserPoint {
        val lock = redissonClient.getLock("point_lock:$userId")
        lock.lock(10, TimeUnit.SECONDS)
        try {
            // 비즈니스 로직
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock()
            }
        }
    }
}
```

#### 장점
- ✅ 분산 환경 지원
- ✅ 유연한 락 제어
- ✅ 자동 락 해제 (TTL)

#### 단점
- ❌ 외부 의존성 (Redis) 필요
- ❌ 네트워크 오버헤드
- ❌ 복잡성 증가
- ❌ Redis 장애 시 영향
  - 레디스 클러스터 등으로 보안 구성 필요
  - 백업 및 장애 조치 전략 필요

---
## 📊 성능 및 특성 비교


### 상세 비교표

| 방법 | 성능 | 구현복잡도 | 확장성 | 분산 환경 지원 |
|------|------|-----------|--------|----|
| @Synchronized | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ❌ |
| ReentrantLock | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ❌ |
| 사용자별 락 | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ❌ |
| 낙관적 락 | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ✅ |
| 비관적 락 | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ✅ |
| Redis 분산 락 | ⭐ | ⭐ | ⭐⭐⭐⭐⭐ | ✅ |


### 요구사항별 전략

#### 단일 서버에서 성능 최적화
```kotlin
// 사용자별 락으로 개선
@Service
class PointService {
    private val userLocks = ConcurrentHashMap<Long, ReentrantLock>()

    private fun executeWithUserLock(userId: Long, action: () -> UserPoint): UserPoint {
        val lock = userLocks.computeIfAbsent(userId) { ReentrantLock() }
        lock.lock()
        try {
            return action()
        } finally {
            lock.unlock()
        }
    }

    override fun charge(userId: Long, amount: Long): UserPoint {
        return executeWithUserLock(userId) {
            // 기존 비즈니스 로직
        }
    }
}
```

#### 분산 환경에서 분산 락킹
```kotlin
// Redis 분산 락 도입
@Service
class PointService {
    @Autowired
    private lateinit var redissonClient: RedissonClient

    private fun executeWithDistributedLock(userId: Long, action: () -> UserPoint): UserPoint {
        val lockKey = "point_lock:$userId"
        val lock = redissonClient.getLock(lockKey)

        return try {
            if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                action()
            } else {
                throw IllegalStateException("락 획득 실패: $userId")
            }
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock()
            }
        }
    }
}
```


## 🎯 결론

### 현재 단일 서버 환경에서 서비스 시 고려사항
1. **사용자별 세밀한 락**: 성능 최적화 (현재 프로젝트 적용)
2. **낙관적 락 도입**: 데이터베이스 기반 동시성 제어
3. **분산 환경 준비**: Redis 분산 락 아키텍처 설계

### 추후 분산 시스템 도입 시 고려사항 (분산 시스템)
1. **Redis 분산 락**: 마이크로서비스 아키텍처 지원

---
